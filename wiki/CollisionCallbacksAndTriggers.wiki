# based on [http://bulletphysics.org/mediawiki-1.5.8/index.php/Collision_Callbacks_and_Triggers]

= Contact Information =

The best way to determine if collisions happened between existing objects in the world, is to iterate over all contact manifolds. This should be done during a simulation tick (substep) callback, because contacts might be added and removed during several substeps of a single stepSimulation call.

A contact manifold is a cache that contains all contact points between pairs of collision objects. A good way is to iterate over all pairs of objects in the entire collision/dynamics world

{{{
//Assume world.StepSimulation or world.PerformDiscreteCollisionDetection has been called

int numManifolds = World.Dispatcher.NumManifolds;
for (int i = 0; i < numManifolds; i++)
{
    PersistentManifold contactManifold = World.Dispatcher.GetManifoldByIndexInternal(i);
    CollisionObject obA = contactManifold.Body0 as CollisionObject;
    CollisionObject obB = contactManifold.Body1 as CollisionObject;

    int numContacts = contactManifold.NumContacts;
    for (int j = 0; j < numContacts; j++)
    {
        ManifoldPoint pt = contactManifold.GetContactPoint(j);
        if (pt.Distance < 0.0f)
        {
            Vector3 ptA = pt.PositionWorldOnA;
            Vector3 ptB = pt.PositionWorldOnB;
            Vector3 normalOnB = pt.NormalWorldOnB;
        }
    }
}
}}}
<wiki:comment>See Bullet/Demos/CollisionInterfaceDemo for a sample implementation.</wiki:comment>

= GhostObject =

A more efficient way is to iterate only over the pairs of objects that you are interested in. This can be done using a GhostObject. A GhostObject keeps track of its own overlapping pairs:

{{{
AlignedManifoldArray manifoldArray = new AlignedManifoldArray();
AlignedBroadphasePairArray pairArray = ghostObject.OverlappingPairCache.OverlappingPairArray;
int numPairs = pairArray.Count;

for (int i = 0; i < numPairs; i++)
{
    manifoldArray.Clear();

    BroadphasePair pair = pairArray[i];

    //unless we manually perform collision detection on this pair, the contacts are in the dynamics world paircache:
    BroadphasePair collisionPair = World.PairCache.FindPair(pair.Proxy0, pair.Proxy1);
    if (collisionPair == null)
        continue;

    if (collisionPair.Algorithm != null)
        collisionPair.Algorithm.GetAllContactManifolds(manifoldArray);

    for (int j = 0; j < manifoldArray.Count; j++)
    {
        PersistentManifold manifold = manifoldArray[j];
        float directionSign = manifold.Body0 == ghostObject ? -1.0f : 1.0f;
        for (int p = 0; p < manifold.NumContacts; p++)
        {
            ManifoldPoint pt = manifold.GetContactPoint(p);
            if (pt.Distance < 0.0f)
            {
                Vector3 ptA = pt.PositionWorldOnA;
                Vector3 ptB = pt.PositionWorldOnB;
                Vector3 normalOnB = pt.NormalWorldOnB;
                /// work here
            }
        }
    }
}
}}}

You have to add once some special callback to world to make the ghosts work.
{{{
DiscreteDynamicsWorld dynamicsWorld = new CreateDiscreteDynamicsWorld(); // Assume the world is now initializing...
dynamicsWorld.PairCache.SetInternalGhostPairCallback(new GhostPairCallback());
}}}
See bulletsharp\demos\Generic\CharacterDemo\CharacterDemo.cs and bullet\src\BulletDynamics\Character\btKinematicCharacterController.cpp (btKinematicCharacterController::recoverFromPenetration) for a sample implementation.

= ContactTest =

Bullet 2.76 onwards let you perform an instant query on the world (CollisionWorld or DiscreteDynamicsWorld) using the contactTest query. The contactTest query will peform a collision test against all overlapping objects in the world, and produces the results using a callback. The query object doesn't need to be part of the world. In order for an efficient query on large worlds, it is important that the broadphase aabbTest is accelerated, for example using the DbvtBroadphase or AxisSweep3 broadphase.

An advantage of this method is that you can perform collision tests at a reduced temporal resolution if you do not need collision tests at every physics tic. It is also convenient to use with a pre-existing object in the world, whereas GhostObject would require synchronizing with the target object. However, a downside is that collision detection is being duplicated for the target object (if it already exists in the world), so frequent or widespread collision tests may become less efficient than iterating over previously generated collision pairs.

Usage example:

{{{
class ContactSensorCallback : CollisionWorld.ContactResultCallback
{
    //! Constructor, pass whatever context you want to have available when processing contacts
    /*! You may also want to set CollisionFilterGroups and CollisionFilterMask
     *  (supplied by the superclass) for NeedsCollision() */
    public ContactSensorCallback(RigidBody tgtBody , object context /*, ... */)
    {
        body = tgtBody;
        ctxt = context;
    }
	
    private RigidBody body; //!< The body the sensor is monitoring
    private object ctxt; //!< External information for contact processing
	
    //! If you don't want to consider collisions where the bodies are joined by a constraint, override NeedsCollision:
    /*! However, if you use a CollisionObject for #body instead of a RigidBody,
     *  then this is unnecessaryâ€”CheckCollideWithOverride isn't available */
    public override bool NeedsCollision(BroadphaseProxy proxy)
    {
	    // superclass will check m_collisionFilterGroup and m_collisionFilterMask
	    if(!base.NeedsCollision(proxy))
		    return false;

	    // if passed filters, may also want to avoid contacts between constraints
	    return body.CheckCollideWithOverride(proxy.ClientObject as CollisionObject);
    }
	
    //! Called with each contact for your own processing (e.g. test if contacts fall in within sensor parameters)
    public override float AddSingleResult(ManifoldPoint cp,
        CollisionObject colObj0, int partId0, int index0,
        CollisionObject colObj1, int partId1, int index1)
    {
	    Vector3 pt; // will be set to point of collision relative to body
	    if(colObj0==body) {
		    pt = cp.LocalPointA;
	    } else {
		    System.Diagnostics.Debug.Assert(colObj1==body);
		    pt = cp.LocalPointB;
	    }
	    // do stuff with the collision point
	    return 0; // not actually sure if return value is used for anything...?
    }
}

///USAGE:
RigidBody tgtBody /* = ... */;
object context = "your context";
ContactSensorCallback callback = new ContactSensorCallback(tgtBody, context);
World.ContactTest(tgtBody,callback);
}}}

= ContactPairTest =

Bullet 2.76 onwards provides the contactPairTest to perform collision detection between two specific collision objects only. Contact results are passed on using the provided callback. They don't need to be inserted in the world. See btCollisionWorld::contactPairTest in Bullet/src/BulletCollision/CollisionDispatch/btCollisionWorld.h for implementation details.

= Contact Callbacks =

Be careful when using contact callbacks. They might be called too frequent for your purpose. Bullet supports custom callbacks at various points in the collision system. The callbacks themselves are very simply implemented as events that you hook up to with appropriate functions. Before you can expect them to be called you must set an appropriate flag in your rigid body:
{{{
body.CollisionFlags |= CollisionFlags.CustomMaterialCallback;
}}}

There are three collision callbacks:

== ManifoldPoint.ContactAdded ==

This is called whenever a contact is added. From here, you can modify some properties [eg friction] of the contact point
{{{
bool OnContactAdded(ManifoldPoint cp, CollisionObjectWrapper colObj0Wrap, int partId0, int index0, CollisionObjectWrapper colObj1Wrap, int partId1, int index1)
{
    return false;
}
ManifoldPoint.ContactAdded += OnContactAdded;
}}}
If your function returns false, then Bullet will assume that you did not modify the contact point properties at all.

== PersistentManifold.ContactProcessed ==

This is called immediately after the collision has been actually processed
{{{
bool OnContactProcessed(ManifoldPoint cp, CollisionObject body0, CollisionObject body1)
{
    return false;
}
PersistentManifold.ContactProcessed += OnContactProcessed;
}}}

== PersistentManifold.ContactDestroyed ==

This is called immediately after the contact point is destroyed.
{{{
bool OnContactDestroyed(object userPersistantData)
{
    return false;
}
PersistentManifold.ContactDestroyed += OnContactDestroyed;
}}}

== Trigger ==

Collision objects with a callback still have collision response with dynamic rigid bodies. In order to use collision objects as trigger, you have to disable the collision response.
{{{
body.CollisionFlags |= CollisionFlags.NoContactResponse;
}}}